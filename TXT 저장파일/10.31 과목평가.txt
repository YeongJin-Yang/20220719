과목평가

1. system call 
커널이 제공하는 서비스에 대해 app의 요청에 따라 커널에 접근하기 위한 인터페이스
고급 API를 통해 시스템 호출에 접근하게 하는 방법
 
2. 디바이스 드라이버 장점?
유지보수가 쉽다.
하드웨어를 변경하면 디바이스 드라이버만 바꾸면된다.
앱(APP) 하드웨어를 신경안써도 된다. 
앱(APP) 그저 system call만 잘 쓰면 됨.
 

3. (주관식문제) 
cross compile  : 개발 PC에서, 타겟 보드에 맞는 펌웨어 개발할 때 사용하는 컴파일
           다른 기종의 CORE에 맞는 컴파일 결과를 내는 컴파일러임
           왜 쓰는데 ? 내 피씨에서 편하게 개발하려고

native compile : 진짜 그 보드에 맞게 컴파일
	왜 쓰는데 ? 해당 보드에 완벽하게 호환시키려고 커널 빌드가 더 빠르진 않다. 오히려 더 느림
	커널 빌드가 더 빠르진 않다. 오히려 더 느림.
커널 빌드는 크로스컴파일, 네이티브 컴파일 둘 다 사용 가능 

4. 커널 이미지
커널은 압축형태 -> 부팅 시에 압축이 해제됨과 동시에 메모리에 적재 (순서를 기억하기)
file 명령어로 확인 -> zImage, bzImage의 이름을 가지고 있음.
부팅 시 부트로더에서 어떤것을 사용할 지 선택할 수 있다.

5. 디바이스 드라이버 개발 시 커널 빌드 왜 하나요?? 
1) 커널 버전에 맞는 디바이스 드라이버 개발
2) 버전업보다는, 커널 헤더를 얻기 위한 목적이 큼.
  - 디바이스 드라이버 개발할 때, 커널헤더가 반드시 필요해서
3) 커널 빌드 make - j4 cpu 코어 갯수와 일치 시킬 때 최적화 
4) 커널 빌드 이후, 하드웨어가 바껴도 디바이스 드라이버만 다시 개발하면 된다.

6. 파일 디스크립터
열려있는 특정파일에 부여한 고유번호,
0이 아닌 정수 값
자료형은 int
open system call의 return값으로 저장 됨.

7. 커널 모듈 추가 삭제
insmod = system all open > module open
rmmod = system all close > module release

8. 커널 모듈 왜 쓰는가?
1) 런타임 도중 커널 내부에 모듈 삽입 가능 
2) 개발의 편의성

9. file operations 구조체 역할 (주관식으로 나올 수 있음)
.read = nobrand_read
system call 사용시, 드라이버에서 호출될 콜백함수 지정

10. 바이트 단위 데이터 전달 목적의 드라이버
char device driver (chrdev)

블럭 단위 데이터 전달 목적의 드라이버
Block Device Driver (blkdev)

11. 커널로그 "실시간" 확인
dmesg -w         w를 쓰지 않으면 그 순간까지의 로그만 출력함

12. 커널 버전 확인 :  uname -r

13. mknod
노트 파일 마드는 유틸리티
디바이스 파일을 만들기 위한 명령어

14. 디바이스파일 Major 넘버:
제어하려는 디바이스를 구분하기 위해 커널이 사용하는 번호의 이름
다른 말로는, 디바이스 파일에서 디바이스를 구분하기 위한 용도임
음수 설정 불가능
마이너 넘버는 개발자가 맘대로 설정 가능
 
15. ioctl
read, write, open, close system call의 일종 
input output control

16. 디바이스 드라이버에서 printf? printk?
printk 사용하면 커널로그를 활용한 간단한 디버깅 가능

17. POST 
컴퓨터 키면 BIOS 주변 장치들 셀프 테스트하는것

18. 부트로더 
운영체제가 사용되기 이전에 미리 실행되면서 커널이 올바르게 동작하기 위해 필요한 모든 관련작업을
마무리하고 OS시동시키기 위한 목적을 가진 프로그램 
ssh로는 접근 안됨. UART 사용해야함.


19. GRUB : 리눅스 배포판에서 가장 자주 사용되는 부트로더.
GRAND Unified Bootloader의 약자임. 

20. u-boot
ARM 계열에서 쓰이는 오픈소스 부트로더
맨 앞에 u는 universal을 뜻함

21. UART
1) 유선통신
2) 부트로더 접근 가능
3) 빠를거 같지만, ssh보다 훨씬 느림
4) 임베디드 보드와의 연결을 위해서 사용 


22. BL0, BL1, BL2 부트로더

BL0 : BL1 부트로더 적재하고, 제어권을 넘기는 역할
외부에 있는 D램을 사용할 수 있도록 세팅하고 
BL1, BL2 : 리눅스 커널을 적재하여 부팅
	
23. CMOS
메모리 크기, 부팅순서, 하드웨어 구성 정보 등을 저장하는 칩셋
배터리 전원 사용.
BIOS 사용해 설정 값 변경 가능

24. BIOS
기본적인 I/O를 위한 펌웨어로서 피씨 부팅 시 바로 동작되는 프로그램이며
씨모스 값도 수정 가능  

25. UEFI
Unified Extensible Firmware Interface (통일 확장 인터페이스)
바이오스 대체하는 펌웨어
화려한 그래픽 UI, 2.2TB이상 디스크 사용을 위한 GPT 지원 

26. 부트로더 펌웨어 vs 리눅스 펌웨어  
부트로더 : OS 부팅 전이라 메모리 접근이 자유롭다.
리눅스 : APP > 하드웨어 접근이 불가능하여 커널 모듈 형태로 디바이스 드라이버 만들고 추가해서 사용한다.

 


